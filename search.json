[{"title":"Virtio over PCI 简介及其实现","date":"2023-03-23T13:10:17.000Z","url":"/2023/03/23/Virtio-over-PCI-%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/","tags":[["操作系统开发","/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/"],["驱动开发","/tags/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"],["PCI","/tags/PCI/"]],"categories":[["DragonOS","/categories/DragonOS/"]],"content":"对于virtio的简介与其在PCI bus上的实现 一、Virtio①Virtio简介virtio 是一种 I&#x2F;O 半虚拟化解决方案，是一套通用 I&#x2F;O 设备虚拟化的程序，是对半拟化Hypervisor中的一组通用 I&#x2F;O 设备的抽象。提供了一套上层应用与各Hypervisor 虚拟化设备（KVM，Xen，VMware等）之间的通信框架和编程接口，减少跨平台所带来的兼容性问题，大大提高驱动程序开发效率。 ②Virtio优势在完全虚拟化的解决方案中，guest VM 要使用底层 host 资源，需要 Hypervisor 来截获所有的请求指令，然后模拟出这些指令的行为，这样势必会带来很多性能上的开销。半虚拟化通过底层硬件辅助的方式，将部分没必要虚拟化的指令通过硬件来完成，Hypervisor 只负责完成部分指令的虚拟化，要做到这点，需要 guest 来配合，guest 完成不同设备的前端驱动程序，Hypervisor 配合 guest 完成相应的后端驱动程序，这样两者之间通过某种交互机制就可以实现高效的虚拟化过程。 由于不同 guest 前端设备其工作逻辑大同小异（如块设备、网络设备等），单独为每个设备定义一套接口实属没有必要，而且还要考虑扩平台的兼容性问题，另外，不同后端 Hypervisor 的实现方式也大同小异（如KVM、Xen等），这个时候，就需要一套通用框架和标准接口（协议）来完成两者之间的交互过程，virtio 就是这样一套标准，它极大地解决了这些不通用的问题。 全虚拟设备交互流程： 默认情况下使用QEMU模拟I&#x2F;O的情况下，当客户机中的设备驱动程序（device driver）发起I&#x2F;O操作请求之时，KVM模块中的I&#x2F;O操作捕获代码会拦截这次I&#x2F;O请求，然后经过处理后将本次I&#x2F;O请求的信息存放到I&#x2F;O共享页，并通知用户控件的QEMU程序。QEMU模拟程序获得I&#x2F;O操作的具体信息之后，交由硬件模拟代码来模拟出本次的I&#x2F;O操作，完成之后，将结果放回到I&#x2F;O共享页，并通知KVM模块中的I&#x2F;O操作捕获代码。最后，由KVM模块中的捕获代码读取I&#x2F;O共享页中的操作结果，并把结果返回到客户机中。当然，这个操作过程中客户机作为一个QEMU进程在等待I&#x2F;O时也可能被阻塞。另外，当客户机通过DMA（Direct Memory Access）访问大块I&#x2F;O之时，QEMU模拟程序将不会把操作结果放到I&#x2F;O共享页中，而是通过内存映射的方式将结果直接写到客户机的内存中去，然后通过KVM模块告诉客户机DMA操作已经完成。 QEMU模拟I&#x2F;O设备的方式，其优点是可以通过软件模拟出各种各样的硬件设备，包括一些不常用的或者很老很经典的设备。在KVM客户机中使用这种方式，对于解决手上没有足够设备的软件开发及调试有非常大的好处。而它的缺点是，每次I&#x2F;O操作的路径比较长，有较多的VMEntry、VMExit发生，需要多次上下文切换（context switch），也需要多次数据复制，所以它的性能较差。 Virtio设备交互流程： 从总体上看，virtio 可以分为四层，包括前端 guest 中各种驱动程序模块（我们实现部分），后端 Hypervisor （实现在Qemu上）上的处理程序模块，中间用于前后端通信的 virtio 层和 virtio-ring 层，virtio 这一层实现的是虚拟队列接口，算是前后端通信的桥梁，而 virtio-ring 则是该桥梁的具体实现，它实现了两个环形缓冲区，分别用于保存前端驱动程序和后端处理程序执行的信息。 Virtio半虚拟化驱动的方式，可以获得很好的I&#x2F;O性能，其性能几乎可以达到和native（即：非虚拟化环境中的原生系统）差不多的I&#x2F;O性能。所以，在使用KVM之时，如果宿主机内核和客户机都支持virtio的情况下，一般推荐使用virtio达到更好的性能。当然，virtio的也是有缺点的，它必须要客户机安装特定的Virtio驱动使其知道是运行在虚拟化环境中，且按照Virtio的规定格式进行数据传输。 二、Virtio over PCIVirtio只是一个半虚拟化标准，或者说是一个协议，协议本身实现的载体和总线并无绑定。virtio协议实现过程中，CPU与外设之间的通知机制以及外设访问内存方式由实际连接CPU与外设的总线协议决定。Virtio根据其实现总线的区别可分为三种：virtio over pci、virtio over mmio、virtio over channel(基本不使用)。虚拟化场景中，主要采用PCI总线协议和MMIO总线协议：采用PCI总线协议的virtio设备叫virtio-pci设备，它可以支持virtio设备的热插拔特性(基于PCI总线的设备热插拔机制)，并可应用于真实物理外设；采用mmio总线协议的virito设备叫virito-mmio设备，它完全是针对虚拟机设计的，是一种轻量的虚拟总线机制，支持快速设备发现，但是无法使用在真实物理外设中。 三、Virtio具体机制（该部分参照rcore文档 Virtio部分）virtio设备交互机制包括基于Notifications的事件通知和基于virtqueue虚拟队列的数据传输。事件通知是指设备和驱动程序必须通知对方，它们有数据需要对方处理。数据传输是指设备和驱动程序之间进行进行I&#x2F;O数据（如磁盘块数据、网络包）传输。 Notification通知驱动程序和设备在交互过程中需要相互通知对方：驱动程序组织好相关命令&#x2F;信息要通知设备去处理I&#x2F;O事务，设备处理完I&#x2F;O事务后，要通知驱动程序进行后续事务，如回收内存，向用户进程反馈I&#x2F;O事务的处理结果等。 驱动程序通知设备可用门铃 doorbell机制，即采用PIO或MMIO方式访问设备特定寄存器，QEMU进行拦截再通知其模拟的设备。设备通知驱动程序一般用中断机制，即在QEMU中进行中断注入，让CPU响应并执行中断处理例程，来完成对I&#x2F;O执行结果的处理。 virtqueue虚拟队列在virtio设备上进行批量数据传输的机制被称为虚拟队列（virtqueue），virtio设备的虚拟队列（virtqueue）可以由各种数据结构（如数组、环形队列等）来具体实现。每个virtio设备可以拥有零个或多个virtqueue，每个virtqueue占用多个物理页，可用于设备驱动程序给设备发I&#x2F;O请求命令和相关数据（如磁盘块读写请求和读写缓冲区），也可用于设备给设备驱动程序发I&#x2F;O数据（如接收的网络包）。 virtio协议中一个关键部分是virtqueue，在virtio规范中，virtqueue是virtio设备上进行批量数据传输的机制和抽象表示。在设备驱动实现和Qemu中virtio设备的模拟实现中，virtqueue是一种数据结构，用于设备和驱动程序中执行各种数据传输操作。 操作系统在Qemu上运行时，virtqueue是 virtio 驱动程序和 virtio 设备访问的同一块内存区域。 当涉及到 virtqueue 的描述时，有很多不一致的地方。有将其与vring（virtio-rings或VRings）等同表示，也有将二者分别单独描述为不同的对象。我们将在这里单独描述它们，因为vring是virtueues的主要组成部分，是达成virtio设备和驱动程序之间数据传输的数据结构， vring本质是virtio设备和驱动程序之间的共享内存，但 virtqueue 不仅仅只有vring。 virtqueue由三部分组成（如下图所示）： 描述符表 Descriptor Table：描述符表是描述符为组成元素的数组，每个描述符描述了一个内存buffer 的address&#x2F;length。而内存buffer中包含I&#x2F;O请求的命令&#x2F;数据（由virtio设备驱动填写），也可包含I&#x2F;O完成的返回结果（由virtio设备填写）等。 可用环 Available Ring：一种vring，记录了virtio设备驱动程序发出的I&#x2F;O请求索引，即被virtio设备驱动程序更新的描述符索引的集合，需要virtio设备进行读取并完成相关I&#x2F;O操作； 已用环 Used Ring：另一种vring，记录了virtio设备发出的I&#x2F;O完成索引，即被virtio设备更新的描述符索引d 集合，需要vrtio设备驱动程序进行读取并对I&#x2F;O操作结果进行进一步处理。 描述符表 Descriptor Table描述符表用来指向virtio设备I&#x2F;O传输请求的缓冲区（buffer）信息，由 Queue Size 个Descriptor（描述符）组成。描述符中包括buffer的物理地址 – addr字段，buffer的长度 – len字段，可以链接到 next Descriptor 的next指针（用于把多个描述符链接成描述符链）。buffer所在物理地址空间需要设备驱动程序在初始化时分配好，并在后续由设备驱动程序在其中填写IO传输相关的命令&#x2F;数据，或者是设备返回I&#x2F;O操作的结果。多个描述符（I&#x2F;O操作命令，I&#x2F;O操作数据块，I&#x2F;O操作的返回结果）形成的描述符链可以表示一个完整的I&#x2F;O操作请求。 可用环 Available Ring可用环在结构上是一个环形队列，其中的条目（item）仅由驱动程序写入，并由设备读出。可用环中的条目包含了一个描述符链的头部描述符的索引值。可用环用头指针（idx）和尾指针（last_avail_idx）表示其可用条目范围。virtio设备通过读取可用环中的条目可获取驱动程序发出的I&#x2F;O操作请求对应的描述符链，然后virtio设备就可以进行进一步的I&#x2F;O处理了。描述符指向的缓冲区具有可读写属性，可读的缓冲区用于Driver发送数据，可写的缓冲区用于接收数据。 比如，对于virtio-blk设备驱动发出的一个读I&#x2F;O操作请求包含了三部分内容，由三个buffer承载，需要用到三个描述符 ：（1） “读磁盘块”，（2）I&#x2F;O操作数据块 – “数据缓冲区”，（3）I&#x2F;O操作的返回结果 –“结果缓冲区”）。这三个描述符形成的一个完成的I&#x2F;O请求链，virtio-blk从设备可通过读取第一个描述符指向的缓冲区了解到是“读磁盘块”操作，这样就可把磁盘块数据通过DMA操作放到第二个描述符指向的“数据缓冲区”中，然后把“OK”写入到第三个描述符指向的“结果缓冲区”中。 已用环 Used Ring已用环在结构上是一个环形队列，其中的的条目仅由virtio设备写入，并由驱动程序读出。已用环中的条目也一个是描述符链的头部描述符的索引值。已用环也有头指针（idx）和尾指针（last_avail_idx）表示其已用条目的范围。 比如，对于virtio-blk设备驱动发出的一个读I&#x2F;O操作请求（由三个描述符形成的请求链）后，virtio设备完成相应I&#x2F;O处理，即把磁盘块数据写入第二个描述符指向的“数据缓冲区”中，可用环中对应的I&#x2F;O请求条目“I&#x2F;O操作的返回结果”的描述符索引值移入到已用环中，把“OK”写入到第三个描述符指向的“结果缓冲区”中，再在已用环中添加一个已用条目，即I&#x2F;O操作完成信息；然后virtio设备通过中断机制来通知virtio驱动程序，并让virtio驱动程序读取已用环中的描述符，获得I&#x2F;O操作完成信息，即磁盘块内容。 上面主要说明了virqueue中的各个部分的作用。对如何基于virtqueue进行I&#x2F;O操作的过程还缺乏一个比较完整的描述。我们把上述基于virtqueue进行I&#x2F;O操作的过程小结一下，大致需要如下步骤： 初始化过程：（驱动程序执行） virtio设备驱动在对设备进行初始化时，会申请virtqueue（包括描述符表、可用环、已用环）的内存空间； 并把virtqueue中的描述符、可用环、已用环三部分的物理地址分别写入到virtio设备中对应的控制寄存器（即设备绑定的特定内存地址）中。至此，设备驱动和设备就共享了整个virtqueue的内存空间。 I&#x2F;O请求过程：（驱动程序执行） 设备驱动在发出I&#x2F;O请求时，首先把I&#x2F;O请求的命令&#x2F;数据等放到一个或多个buffer中； 然后在描述符表中分配新的描述符（或描述符链）来指向这些buffer； 再把描述符（或描述符链的首描述符）的索引值写入到可用环中，更新可用环的idx指针； 驱动程序通过 kick 机制（即写virtio设备中特定的通知控制寄存器）来通知设备有新请求； I&#x2F;O完成过程：（设备执行） virtio设备通过 kick 机制（知道有新的I&#x2F;O请求，通过访问可用环的idx指针，解析出I&#x2F;O请求； 根据I&#x2F;O请求内容完成I&#x2F;O请求，并把I&#x2F;O操作的结果放到I&#x2F;O请求中相应的buffer中； 再把描述符（或描述符链的首描述符）的索引值写入到已用环中，更新已用环的idx指针； 设备通过再通过中断机制来通知设备驱动程序有I&#x2F;O操作完成； I&#x2F;O后处理过程：（驱动程序执行） 设备驱动程序读取已用环的idx信息，读取已用环中的描述符索引，获得I&#x2F;O操作完成信息。 四、DragonOS实现Virtio-netrCore提供了virtio-drivers库，目前最新版本为virtio-drivers 0.3.0。但其目前仅支持使用MMIO总线与Memory-mapped CAM的PCI总线的系统，这与我们系统有很大差异。于是我重写了virtio-drivers库的pci transport，使其在满足virtio-drivers的Transport trait的同时又能够正确使用我们操作系统的pci底层代码，将virtio-drivers库的发送逻辑与我们操作系统的底层架构结合起来，最终实现了Virtio-net（留有为其他Virtio设备准备的接口，以后其他常见Virtio设备添加进来简单修改下代码也能进行驱动）。 具体实现：①寻找Virtio-pci设备"},{"title":"Hello World","date":"2023-03-22T08:47:25.872Z","url":"/2023/03/22/hello-world/","categories":[["undefined",""]],"content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post More info: Writing Run server More info: Server Generate static files More info: Generating Deploy to remote sites More info: Deployment"}]